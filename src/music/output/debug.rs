use super::{OutputAdapter, TimedEvent};
use crate::music::pattern::EventData;
use std::collections::VecDeque;
use std::fmt;

/// Debug output adapter that prints events to console and stores them for inspection
/// This is useful for testing and development, providing human-readable output
/// of musical events as they are generated by the scheduler.
pub struct DebugOutput {
    name: String,
    event_history: VecDeque<TimedEvent>,
    max_history: usize,
    show_timestamps: bool,
    show_cycle_times: bool,
    compact_mode: bool,
}

impl DebugOutput {
    pub fn new(name: String) -> Self {
        DebugOutput {
            name,
            event_history: VecDeque::new(),
            max_history: 100,
            show_timestamps: true,
            show_cycle_times: true,
            compact_mode: false,
        }
    }
    
    /// Create a debug output with default name "debug"
    pub fn default() -> Self {
        Self::new("debug".to_string())
    }
    
    /// Set the maximum number of events to keep in history
    pub fn with_max_history(mut self, max_history: usize) -> Self {
        self.max_history = max_history;
        self
    }
    
    /// Configure what timing information to show
    pub fn with_timing_options(mut self, show_timestamps: bool, show_cycle_times: bool) -> Self {
        self.show_timestamps = show_timestamps;
        self.show_cycle_times = show_cycle_times;
        self
    }
    
    /// Enable compact output mode (less verbose)
    pub fn with_compact_mode(mut self, compact: bool) -> Self {
        self.compact_mode = compact;
        self
    }
    
    /// Get the event history for inspection
    pub fn get_history(&self) -> &VecDeque<TimedEvent> {
        &self.event_history
    }
    
    /// Clear the event history
    pub fn clear_history(&mut self) {
        self.event_history.clear();
    }
    
    /// Get the last N events from history
    pub fn get_recent_events(&self, count: usize) -> Vec<&TimedEvent> {
        self.event_history
            .iter()
            .rev()
            .take(count)
            .rev()
            .collect()
    }
    
    /// Count events by pattern name
    pub fn count_events_by_pattern(&self) -> std::collections::HashMap<String, usize> {
        let mut counts = std::collections::HashMap::new();
        
        for event in &self.event_history {
            *counts.entry(event.pattern_name.clone()).or_insert(0) += 1;
        }
        
        counts
    }
    
    /// Format an event for display
    fn format_event(&self, event: &TimedEvent) -> String {
        if self.compact_mode {
            self.format_compact(event)
        } else {
            self.format_verbose(event)
        }
    }
    
    fn format_compact(&self, event: &TimedEvent) -> String {
        match &event.data {
            EventData::Note { pitch, velocity, duration } => {
                format!("â™ª {} {} v{:.2} d{:.2}", 
                    event.pattern_name, pitch, velocity, duration)
            },
            EventData::Rest => {
                format!("â™ª {} ~", event.pattern_name)
            },
            EventData::Control { param, value } => {
                format!("â™ª {} {}={:.2}", event.pattern_name, param, value)
            },
        }
    }
    
    fn format_verbose(&self, event: &TimedEvent) -> String {
        let mut parts = Vec::new();
        
        // Pattern name
        parts.push(format!("[{}]", event.pattern_name));
        
        // Timing information
        if self.show_timestamps && self.show_cycle_times {
            parts.push(format!("@{:.3}s (cycle:{:.3})", event.timestamp, event.cycle_time));
        } else if self.show_timestamps {
            parts.push(format!("@{:.3}s", event.timestamp));
        } else if self.show_cycle_times {
            parts.push(format!("(cycle:{:.3})", event.cycle_time));
        }
        
        // Event data
        match &event.data {
            EventData::Note { pitch, velocity, duration } => {
                parts.push(format!("â™ª {} (v:{:.2}, d:{:.2})", pitch, velocity, duration));
            },
            EventData::Rest => {
                parts.push("â™ª ~".to_string());
            },
            EventData::Control { param, value } => {
                parts.push(format!("â™ª {}={:.2}", param, value));
            },
        }
        
        parts.join(" ")
    }
}

impl OutputAdapter for DebugOutput {
    fn send_event(&mut self, event: &TimedEvent) -> Result<(), String> {
        // Store in history
        self.event_history.push_back(event.clone());
        
        // Maintain history size limit
        if self.event_history.len() > self.max_history {
            self.event_history.pop_front();
        }
        
        // Print to console
        println!("{}", self.format_event(event));
        
        Ok(())
    }
    
    fn name(&self) -> &str {
        &self.name
    }
    
    fn start(&mut self) -> Result<(), String> {
        println!("ğŸµ Debug output '{}' started", self.name);
        Ok(())
    }
    
    fn stop(&mut self) -> Result<(), String> {
        println!("ğŸµ Debug output '{}' stopped ({} events processed)", 
                 self.name, self.event_history.len());
        Ok(())
    }
}

impl fmt::Display for DebugOutput {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "DebugOutput[{}] ({} events in history)", 
               self.name, self.event_history.len())
    }
}

/// Console output adapter - simpler version that just prints events
/// without storing history (more lightweight for basic debugging)
pub struct ConsoleOutput {
    name: String,
    prefix: String,
}

impl ConsoleOutput {
    pub fn new(name: String) -> Self {
        let prefix = format!("â™ª [{}]", name);
        ConsoleOutput { name, prefix }
    }
    
    pub fn default() -> Self {
        Self::new("console".to_string())
    }
}

impl OutputAdapter for ConsoleOutput {
    fn send_event(&mut self, event: &TimedEvent) -> Result<(), String> {
        match &event.data {
            EventData::Note { pitch, velocity, duration } => {
                println!("{} {} (v:{:.2}, d:{:.2})", self.prefix, pitch, velocity, duration);
            },
            EventData::Rest => {
                println!("{} ~", self.prefix);
            },
            EventData::Control { param, value } => {
                println!("{} {}={:.2}", self.prefix, param, value);
            },
        }
        Ok(())
    }
    
    fn name(&self) -> &str {
        &self.name
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    // EventData imported via super::*

    #[test]
    fn test_debug_output_basic() {
        let mut debug = DebugOutput::new("test".to_string());
        
        let event = TimedEvent::note(
            1.0, 0.5, "pattern1".to_string(), 
            "c3".to_string(), 0.8, 0.1
        );
        
        assert!(debug.send_event(&event).is_ok());
        assert_eq!(debug.get_history().len(), 1);
        assert_eq!(debug.get_history()[0].pattern_name, "pattern1");
    }

    #[test]
    fn test_debug_output_history_limit() {
        let mut debug = DebugOutput::new("test".to_string()).with_max_history(2);
        
        for i in 0..5 {
            let event = TimedEvent::rest(i as f64, 0.0, format!("pattern{}", i));
            debug.send_event(&event).unwrap();
        }
        
        // Should only keep last 2 events
        assert_eq!(debug.get_history().len(), 2);
        assert_eq!(debug.get_history()[0].pattern_name, "pattern3");
        assert_eq!(debug.get_history()[1].pattern_name, "pattern4");
    }

    #[test]
    fn test_debug_output_recent_events() {
        let mut debug = DebugOutput::new("test".to_string());
        
        for i in 0..5 {
            let event = TimedEvent::rest(i as f64, 0.0, format!("pattern{}", i));
            debug.send_event(&event).unwrap();
        }
        
        let recent = debug.get_recent_events(3);
        assert_eq!(recent.len(), 3);
        assert_eq!(recent[0].pattern_name, "pattern2");
        assert_eq!(recent[1].pattern_name, "pattern3");
        assert_eq!(recent[2].pattern_name, "pattern4");
    }

    #[test]
    fn test_event_counting() {
        let mut debug = DebugOutput::new("test".to_string());
        
        // Send multiple events from different patterns
        for _ in 0..3 {
            debug.send_event(&TimedEvent::rest(0.0, 0.0, "pattern1".to_string())).unwrap();
        }
        for _ in 0..2 {
            debug.send_event(&TimedEvent::rest(0.0, 0.0, "pattern2".to_string())).unwrap();
        }
        
        let counts = debug.count_events_by_pattern();
        assert_eq!(counts.get("pattern1"), Some(&3));
        assert_eq!(counts.get("pattern2"), Some(&2));
    }

    #[test]
    fn test_console_output() {
        let mut console = ConsoleOutput::new("test".to_string());
        
        let event = TimedEvent::note(
            1.0, 0.5, "pattern1".to_string(),
            "c3".to_string(), 0.8, 0.1
        );
        
        // Should not error
        assert!(console.send_event(&event).is_ok());
        assert_eq!(console.name(), "test");
    }
}